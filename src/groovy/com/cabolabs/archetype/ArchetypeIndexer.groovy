package com.cabolabs.archetypeimport org.openehr.am.archetype.Archetypeimport org.openehr.am.archetype.constraintmodel.*import ehr.clinical_documents.DataIndeximport org.codehaus.groovy.grails.commons.ApplicationHolderclass ArchetypeIndexer {      /**    * TODO: hay paths que existen en el RM y no estan en el AM, son atributos    *       obligatorios. Crear la path depende del RM TYPE del nodo que se    *       esta procesando, ej. ACTION tiene un atributo time, entonces hay que crear la path a ese atributo    */   def rmAttributes = [     'COMPOSITION': [      'language',    // CodePhrase      'territory',   // CodePhrase      'category',    // DvCodedText      'composer'     // PartyProxy como consultar por atributos de PartyProxy ??? hay que crear indices ????    ],    'EVENT_CONTEXT': [      'start_time', // DvDateTime      'end_time',   // DvDateTime      'location',   // String      'setting',    // DvCodedText      'health_care_facility', // PartyIdentified      'participations' // List<Participation> como consultar esto ??? hay que crear indices ????    ],    // each entry subclass include attributes from ENTRY    'ADMIN_ENTRY': [      'language',      'encoding',      'subject',      'provider',      'other_participations',      'workflow_id'    ],    'OBSERVATION': [      'language',      'encoding',      'subject',      'provider',      'other_participations',      'workflow_id',      'protocol',      'guideline_id'    ],    'EVALUATION': [      'language',      'encoding',      'subject',      'provider',      'other_participations',      'workflow_id',      'protocol',      'guideline_id'    ],    'INSTRUCTION': [      'language',      'encoding',      'subject',      'provider',      'other_participations',      'workflow_id',      'protocol',      'guideline_id',      'narrative',      'expiry_time',      'wf_definition'    ],    'ACTION': [      'language',      'encoding',      'subject',              // PartyProxy      'provider',             // PartyProxy      'other_participations', // List<Participation> como consulto esto??? necesito crear indices de Participation ???      'workflow_id',          // ObjectRef      'guideline_id',         // ObjectRef      'time'                  // DvDateTime    ],    'ACTIVITY': [      'timing',               // DvParsable      'action_archetype_id'   // String    ],    'ISM_TRANSITION': [      'current_state',        // DvCodedText      'transition',           // DvCodedText      'careflow_step'         // DvCodedText    ],    'INSTRUCTION_DETAILS': [      'instruction_id',       // LocatableRef      'activity_id'           // String    ],    'HISTORY': [      'origin',               // DvDateTime      'period',               // DvDuration      'duration'              // DvDuration    ],    'EVENT': [ // this class is abstract, should not be present on flat archetype      'time'                  // DvDateTime    ],    'POINT_EVENT': [      'time'                  // DvDateTime    ],    'INTERVAL_EVENT': [      'width',                // DvDuration      'sample_count',         // Integer      'math_function'         // DvCodedText    ],    'ELEMENT': [      'null_flavour'          // DvCodedText    ],    'DvQuantity': [      'units',      'magnitude',      'precision'    ],    'DV_TEXT': [       'value'    ],    'DV_CODED_TEXT': [       'value',       'defining_code/code_string',       'defining_code/terminology_id'    ]   ]      def archetype   def indexes = []      // elems?   // [archetypeId:'openEHR-EHR-COMPOSITION.encounter.v1', path:'/context/setting', rmTypeName:'DV_CODED_TEXT']   def dataIndexes = []   def index(String archetypeId)   {      def manager = ArchetypeManager.getInstance()      this.archetype = manager.getArchetype(archetypeId)                  this.archetype.physicalPaths().sort().each { path ->         println path +" "+ this.archetype.node(path).rmTypeName                  if (!this.archetype.node(path).getParent())           println " * Parent: empty"         else           println " * Parent: " + this.archetype.node(path).getParent().rmAttributeName +" "+                 this.archetype.node(path).getParent().path()                  this.rmAttributes[this.archetype.node(path).rmTypeName].each { attr ->           println " - "+ attr         }      }            /*      this.archetype.getPathNodeMap().each { path, cobj ->         println path +" => "+ cobj.rmTypeName      }      */                 if (!this.archetype) throw new Exception("Arquetipo $archetypeId no encontrado")           // recursiva      //indexConstraintObject(this.archetype.definition)   }   private void indexConstraintObject(CComplexObject co)   {      if (!co.attributes || co.attributes.size()==0)      {         println "CCOe: "+ co.path() +" "+ co.rmTypeName +" "+ this.rmAttributes[co.rmTypeName]      }      else      {         println "CCOf: "+ co.path() +" "+ co.rmTypeName +" "+ this.rmAttributes[co.rmTypeName]         co.attributes.each { ca ->            indexConstraintAttribute(ca)         }      }   }   private void indexConstraintObject(CDomainType co)   {      /* CDomainType es abstracta      puede ser CCodePhrase, CDvOrdinal, CDvQuantity, CDvState      co.attirbutes.each { ca ->        indexConstraintAttribute(ca)      }      */      println "CDT: "+ co.path() +" "+ co.rmTypeName +" "+ co.class.simpleName +" "+ co.nodeID          // El tipo de dominio no tiene nodeID porque corresponde a ELEMENT.value     // Deberia pedir el nodeID del padre, pero el arquetipo tiene los parent == null     // TODO: clonar el adl parser y corregir lo de los parents.          def locale = ApplicationHolder.application.config.app.l10n.locale     def term = this.archetype.ontology.termDefinition(locale, co.nodeID)     if (!term)     {        println "ERROR: termino no definido para el nodo "+ co.nodeID     }          //indexes << new DataIndex(archetypeId: this.archetype.archetypeId.value, path: co.path(), rmTypeName: co.rmTypeName, name: term.getText())   }   private void indexConstraintObject(CPrimitiveObject co)   {      //solo tiene .item CPrimitive     println "CPR: "+ co.path() +" "+ co.rmTypeName   }   private void indexConstraintObject(CReferenceObject co)   {      throw new Exception("Reference found: only flat archetypes allowed "+ this.archetype.archetypeId.value +" "+ co.path())   }         private void indexConstraintAttribute(CAttribute ca)   {      if (!ca.children || ca.children.size()==0)      {         println "CAT: no tiene children "+ ca.path()      }      ca.children.each { co ->         indexConstraintObject(co)      }   }}