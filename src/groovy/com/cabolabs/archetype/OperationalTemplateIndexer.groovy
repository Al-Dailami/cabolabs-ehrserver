package com.cabolabs.archetypeimport org.openehr.am.archetype.Archetypeimport org.openehr.am.archetype.constraintmodel.*import ehr.clinical_documents.DataIndeximport org.codehaus.groovy.grails.commons.ApplicationHolderimport groovy.util.slurpersupport.*/* * DataIndex generator. */class OperationalTemplateIndexer {      private static String PS = System.getProperty("file.separator")      def template   def indexes = []      // elems?   // [archetypeId:'openEHR-EHR-COMPOSITION.encounter.v1', path:'/context/setting', rmTypeName:'DV_CODED_TEXT']   def dataIndexes = []   // test...   def paths = []      def indexAll()   {      def path = "opts" + PS      def repo = new File( path )            if (!repo.exists())  throw new Exception("No existe "+ path)      if (!repo.canRead())  throw new Exception("No se puede leer "+ path)      if (!repo.isDirectory())  throw new Exception("No es un directorio "+ path)            repo.eachFileMatch groovy.io.FileType.FILES, ~/.*\.opt/, { file ->                  println file.name         index(file)      }   }      def index(File templateFile)   {      if (!templateFile.exists())  throw new Exception("No existe "+ path)      if (!templateFile.canRead())  throw new Exception("No se puede leer "+ path)      if (!templateFile.isFile())  throw new Exception("No es un archivo "+ path)            this.template = new XmlSlurper().parseText( templateFile.getText() ) // GPathResult            indexObject(this.template.definition, '/')            println this.paths // test   }      /*    * templateFileName es el nombre del archivo sin la extension.    */   def index(String templateFileName)   {      def path = "opts" + PS + templateFileName + ".opt"      def tfile = new File( path )      index(tfile)   }      def indexAttribute(GPathResult node, String parentPath)   {      if (!node) throw new Exception("Nodo vacio")            //println node.name()            // test      //this.paths << parentPath            node.children.each {         //println "child "+ it.name()                  if (parentPath == '/') indexObject(it, parentPath + node.rm_attribute_name.text())         else indexObject(it, parentPath +'/'+ node.rm_attribute_name.text())      }   }      /*    * Procesa nodos objeto de la definicion del template.    */   def indexObject (GPathResult node, String parentPath)   {      if (!node) throw new Exception("Nodo vacio")            //println node.name()            // comienza de nuevo con las paths relativas al root de este arquetipo      if (!node.archetype_id.value.isEmpty())      {         println ""         println "archid: "+ node.archetype_id.value         parentPath = '/'      }            // test      this.paths << parentPath            // test      if (parentPath.endsWith('category'))      {         if (node.node_id.isEmpty()) println 'node_id empty'         else println 'node_id NOT empty'                           if (node.node_id.text() == '') println 'node_id empty text'         else println 'node_id NOT empty text'                           println 'node_id size '+ node.node_id.size()         println 'node_id [0] '+ node.node_id[0]         println 'node_id text '+ node.node_id.text()      }            def path = parentPath      if (path != '/' && !node.node_id.isEmpty() && node.node_id.text() != '') // para tag vacia empty da false pero text es vacio.      {         path += '['+ node.node_id.text() + ']'      }      node.attributes.each {         //println "attr "+ it.name()         indexAttribute(it, path) // No pone su nodeID porque es root      }            /*      // CObject      def co      def nodeID      def indexPath      def text            this.archetype.physicalPaths().sort().each { path ->              co = this.archetype.node(path)                // No procesa el nodo /         if (!co.getParent()) return                      // Indices de nivel 2 solo para ELEMENT.value         if (co.rmTypeName == "ELEMENT")         {            nodeID = co.nodeID                        if (!nodeID) throw new Exception("No tiene nodeID: ELEMENT indefinido")                     // node name            def locale = ApplicationHolder.application.config.app.l10n.locale            def term = this.archetype.ontology.termDefinition(locale, nodeID)            if (!term)            {               //println " + ERROR: termino no definido para el nodo "+ nodeID            }            else            {               //println " + Node name = "+ term.getText()            }                        // FIXME: JAVA REF IMPL los tipos del RM son DvQuantity en lugar de DV_QUANTITY            //println " ~ index "+ co.path() +"/value "+ this.archetype.node( co.path() +"/value" ).rmTypeName                        indexPath = co.path() +"/value"                        indexes << new DataIndex(archetypeId: this.archetype.archetypeId.value,                                     path: indexPath,                                     rmTypeName: this.archetype.node( indexPath ).rmTypeName, // type de ELEMENT.value ej. DvQuantity                                     name: term.getText())                        //println ""         }      } // physical paths            indexes.each { di ->                  if (!di.save())         {            println "======================"            println di.errors            println "======================"         }      }     */   }}